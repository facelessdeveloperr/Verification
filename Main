--!strict

--[[Author: Yonas_Dev/FacelessDeveloper]]--

local Players : Players = game:GetService("Players"); --gets the players service so we can loop players
local Teams : Teams = game:GetService("Teams"); --gets the teams service where we will put teams each round

local Teleports : Folder = workspace:WaitForChild("Teleports"); --folder that holds teleport locations
local arenaTeleport : BasePart = Teleports:WaitForChild("Arena") :: BasePart; --where players go when the match starts
local lobbyTeleport : BasePart = Teleports:WaitForChild("Lobby") :: BasePart; --where players return after the match ends

local Sides : Folder = workspace:WaitForChild("Sides"); --folder that contains the team pads
local redLock : BasePart = Sides:WaitForChild("Red") :: BasePart; --pad for red team selection
local blueLock : BasePart = Sides:WaitForChild("Blue") :: BasePart; --pad for blue team selection

local ReplicatedStorage = game:GetService("ReplicatedStorage") --storage for remotes and shared data
local RoundRemotes : Folder = ReplicatedStorage:WaitForChild("RoundRemotes"); --remotes used for round updates
local updateLocal : RemoteEvent = RoundRemotes:WaitForChild("UpdateLocal") :: RemoteEvent; --client ui update event
local updateInvisibility : RemoteEvent = RoundRemotes:WaitForChild("UpdateInvisibility") :: RemoteEvent; --hides/unhides characters locally

local redTeam : Team; --reference to red team created each round
local blueTeam : Team; --reference to blue team created each round

local MAIN_COUNTDOWN : number = 5; --countdown before teleporting to arena
local CHOOSE_COUNTDOWN : number = 2; --time players have to choose a pad
local PLAYERS_NEEDED : number = 1; --min players needed to start a match

function toggleLight() --turns lights on and off to show game state changes
	for _, light : SurfaceLight in workspace:QueryDescendants("SurfaceLight") do --loops through lights anywhere in workspace
		if light:IsA("SurfaceLight") then --make sure this is actually a surface light
			if light.Brightness == 0 then --if light is currently off
				light.Brightness = 1 --turn it on
			else
				light.Brightness = 0 --otherwise turn it off
			end
		end
	end
end

function teleport() : () --teleports and hides players before the match starts
	for _, player : Player in (Players:GetPlayers()) do --loops each player in the game
		local character : Model = player.Character :: Model --get player character
		if character then --if character exists
			for _, part : BasePart in character:QueryDescendants("BasePart") :: {BasePart} do --hide limbs and torso
				part.Transparency = 1 --invisible
			end
			for _, decal : Decal in character:QueryDescendants("Decal") :: {Decal} do --hide character decals
				decal.Transparency = 1 --invisible
			end
		end
		character:PivotTo(arenaTeleport.CFrame + Vector3.new(0,4,0)) --move slightly above arena pad
		updateInvisibility:FireClient(player) --tell client to hide whatever else needed
	end
end

function ensureEnoughPlayers() : () --pauses system until enough players join
	local players : {Player} = Players:GetPlayers() --get current player count
	if #players < PLAYERS_NEEDED then --not enough players
		repeat --wait loop
			task.wait(5) --checks every 5 seconds
			updateLocal:FireAllClients("players") --tells ui to show waiting message
			players = Players:GetPlayers() --refresh list
		until #players >= PLAYERS_NEEDED --until enough
	end
end

function mainCountdown() : () --lobby countdown before teleporting to arena
	updateLocal:FireAllClients("main", MAIN_COUNTDOWN) --update ui countdown
	for i = MAIN_COUNTDOWN, 1, -1 do --tick down
		print(i) --debug
		task.wait(1) --1 sec wait per number
	end
end

function teamLock() : () --gives teams to anyone who didn’t pick one
	for _, player : Player in (Players:GetPlayers()) do --loop players
		if player.Team ~= redTeam and player.Team ~= blueTeam then --if they didn’t pick a pad
			local character : Model = player.Character :: Model; --get character reference
			local Humanoid : Humanoid = character:FindFirstChildOfClass("Humanoid") :: Humanoid; --get humanoid
			local randomNum = math.random(1, 2) --randomly decide their team
			if randomNum == 1 then --assign red
				player.Team = redTeam
				if character and Humanoid then --freeze them in place
					character:PivotTo(redLock.CFrame + Vector3.new(0,4,0));
					Humanoid.WalkSpeed = 0;
					Humanoid.JumpPower = 0;
				end
			else --assign blue
				player.Team = blueTeam
				if character and Humanoid then --freeze them in place
					character:PivotTo(blueLock.CFrame+ Vector3.new(0,4,0));
					Humanoid.WalkSpeed = 0;
					Humanoid.JumpPower = 0;
				end
			end
		end
	end
end


function choosingCountdown() : (RBXScriptConnection, RBXScriptConnection) --creates teams and waits for pad choices
	
	redTeam = Instance.new("Team") --create red team fresh each round
	redTeam.TeamColor = BrickColor.Red() --color used in ui
	redTeam.Name = "Red" --id
	redTeam.AutoAssignable = false --players should not auto join this
	redTeam.Parent = Teams; --put inside teams service
	
	blueTeam = Instance.new("Team") --repeat same setup for blue
	blueTeam.Name = "Blue"
	blueTeam.AutoAssignable = false
	blueTeam.TeamColor = BrickColor.Blue()
	blueTeam.Parent = Teams;
	
	
	local redConnection = redLock.Touched:Connect(function(hit : BasePart) --player touches red pad
		local player : Player = Players:GetPlayerFromCharacter(hit.Parent :: Model) --find player by character
		if player and player.Team == nil then --only if they dont have a team yet
			player.Team = redTeam; --move them to red
			local character : Model = player.Character :: Model;
			local Humanoid : Humanoid = character:FindFirstChildOfClass("Humanoid") :: Humanoid;
			if character and Humanoid then --freeze player to show they locked
				character:PivotTo(redLock.CFrame + Vector3.new(0,4,0))
				Humanoid.WalkSpeed = 0;
				Humanoid.JumpPower = 0;
			end
		end
	end)

	local blueConnection = blueLock.Touched:Connect(function(hit : BasePart) --player touches blue pad
		local player : Player = Players:GetPlayerFromCharacter(hit.Parent :: Model)
		if player and player.Team == nil then --lock if needed
			player.Team = blueTeam;
			local character : Model = player.Character :: Model;
			local Humanoid : Humanoid = character:FindFirstChildOfClass("Humanoid") :: Humanoid;
			if character and Humanoid then --freeze player after clicking team
				character:PivotTo(blueLock.CFrame + Vector3.new(0,4,0))
				Humanoid.WalkSpeed = 0;
				Humanoid.JumpPower = 0;			
			end
		end
	end)

	updateLocal:FireAllClients("choose", CHOOSE_COUNTDOWN) --inform ui to start countdown
	for i = CHOOSE_COUNTDOWN, 1, -1 do --countdown loop
		print(i) --debug
		task.wait(1) --tick down one second
	end

	return redConnection, blueConnection --return listeners so we can kill them later
end

function sortTeams() : () --placeholder for future logic
	for _, player : Player in (Players:GetPlayers()) do --loop players
		local character : Model = player.Character :: Model --just grabbing character, not doing anything yet
		if character then
		end
	end
end

function begin() : () --battle officially begins
	task.wait(0.5) --tiny delay for smoothness
	updateLocal:FireAllClients("fight", MAIN_COUNTDOWN) --switch ui to fight mode
	for _, player : Player in (Players:GetPlayers()) do --loop players
		local character : Model = player.Character :: Model
		local Humanoid : Humanoid = character:FindFirstChild("Humanoid") :: Humanoid;
		local HumanoidRootPart = character:FindFirstChild("HumanoidRootPart") :: BasePart;
		if character then --show characters now
			for _, part : BasePart in character:QueryDescendants("BasePart") :: {BasePart} do
				part.Transparency = 0
			end
			for _, decal : Decal in character:QueryDescendants("Decal") :: {Decal} do
				decal.Transparency = 0
			end
		end
		HumanoidRootPart.Transparency = 1; --keep hrp hidden though
		Humanoid.WalkSpeed = 16; --restore movement
		Humanoid.JumpPower = 32; --restore jump

		_G.playerInventories[player]:giveWeapon() --equip starting weapon
	end
end

function roundEnd() : () --checks who wins the round
	while task.wait(1) do --checks every second
		if #redTeam:GetPlayers() == 0 then --blue team wins
			print("Blue Won!")
			break
		elseif #blueTeam:GetPlayers() == 0 then --red team wins
			print("Red Won!")
			break
		end
	end
	if #redTeam:GetPlayers() == 0 then --reward blue players
		updateLocal:FireAllClients("wonBlue")
		for _, player in ipairs(blueTeam:GetPlayers()) do
			local stats : Folder = player:FindFirstChild("leaderstats") :: Folder
			local gems : IntValue = stats and stats:FindFirstChild("Gems") :: IntValue
			if gems then
				gems.Value += 30 --give gems for winning
			end
		end
		
	else --reward red players
		updateLocal:FireAllClients("wonRed")
		for _, player in ipairs(redTeam:GetPlayers()) do
			local stats : Folder = player:FindFirstChild("leaderstats") :: Folder
			local gems : IntValue = stats and stats:FindFirstChild("Gems") :: IntValue
			if gems then
				gems.Value += 30 --give gems for winning
			end
		end
	end
	
	task.wait(5) --pause before teleporting out
	print("Teleporting Now!") --debug message
	for _, player : Player in (Players:GetPlayers()) do --loop players
		local character : Model = player.Character :: Model
		if character and character:FindFirstChildOfClass("Tool") then --remove their weapon if they have one
			_G.playerInventories[player]:removeWeapon()
			character:PivotTo(lobbyTeleport.CFrame) --send to lobby
			player.Team = nil --clear team assignment
		end
	end
end


while true do --main round cycle loop forever
	ensureEnoughPlayers() --wait until enough players join
	mainCountdown(); --countdown before teleport
	teleport(); --move everyone to arena
	toggleLight() --lights change so players know something is happening
	local redC, blueC = choosingCountdown(); --allow team choose
	teamLock(); --assign to random if not chosen
	toggleLight() --switch lights again to signal start soon
	begin() --start the combat
	roundEnd() --check who wins
	redC, blueC = nil, nil; --wipe event references
	redTeam:Destroy() --remove red team instance
	blueTeam:Destroy() --remove blue team instance
end --then repeat from the top
